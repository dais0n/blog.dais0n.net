<!doctype html><html><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>dotfilesの設定 in 2019</title>
<link rel=icon href=https://blog.dais0n.net/favicon.ico><link rel=stylesheet href=https://blog.dais0n.net//css/style.css><link rel=alternate type=application/atom+xml href=https://blog.dais0n.net//index.xml title=blog.dais0n.net><body><div id=content><header id=header></header><section id=main><header><h1 id=title>dotfilesの設定 in 2019</h1><div class=tags><span class=tag><a href=https://blog.dais0n.net/tags/zsh>zsh</a></span></div></header><article><h2 id=背景>背景</h2><p>自分はサーバにdotfilesや必要なコマンドをインストールするスクリプトを用意していて、サーバに入るとそのスクリプトを走らせることで
基本どのサーバでも同じ環境で作業できるようにしてます。</p><p>今回はインストールスクリプトや</p><ul><li>どういったコマンドや設定を入れているのか、またその設定を入れる理由</li><li>OSの違いなどをどう解決しているのか</li></ul><p>を紹介できればと思います。ローカルとサーバでパフォーマンスが変わってしまうのはもったいない！</p><h2 id=ゴール>ゴール</h2><p>早速ですが、自分が初めてサーバに入ると走らせているスクリプトのgifです。<figure><img src=../../../images/dotfiles_in_anywhere_1.gif></figure>上記の動画のように</p><ul><li>dotfilesのクローン</li><li>必要なコマンドやプラグインマネージャなどインストール</li><li>vimのプラグインを入れる</li><li>dotfilesにシンボリックリンクを貼る</li><li>zshを再起動
といったことをしてます。ここまでできるようになるのが本記事のゴールです。</li></ul><p>サーバに入ったら必ず走らせるスクリプトなので、プラグインやコマンドはできるだけ最低限にするようにdotfilesを作るようにしてます。インストール方法は後ほど書きます</p><h2 id=dotfilesの作成>dotfilesの作成</h2><p>どの環境からでも同じ設定ファイル類をダウンロードする必要があるので、githubにvimrc、zshrcなどをまとめたdotfilesというリポジトリを作ります。ついでに自分がどの環境でも入れているコマンドも紹介します。</p><p>自分のdotfilesは<a href=https://github.com/dais0n/dotfiles>こちら</a>です。</p><p>また、各設定の解説をすると長くなるため各設定で自分が意識していることを中心に記載します。</p><h3 id=必要なコマンド>必要なコマンド</h3><p>自分がどの環境でも入れているコマンド。</p><ul><li><a href=https://github.com/peco/peco>peco</a>: フィルタリングツール。ディレクトリ移動、コマンド履歴。真面目にこれないと仕事ができない</li><li><a href=https://github.com/motemen/ghq>ghq</a>: gitリポジトリの統一的な管理。色々サーバ入っているとどこにcloneしたのかわからなくなるので必須。またpecoと組み合わせるとリポジトリをすぐ見つけることができる。</li><li><a href=https://github.com/ggreer/the_silver_searcher>ag</a>: 高速grepツール。ソースコードを検索する際に使う</li></ul><h3 id=zshrc>zshrc</h3><p>続いてzshrcです。自分のzshrcは200行くらいしかなく短いのですが、意識していることは</p><h4 id=履歴を利用する設定を入れる>履歴を利用する設定を入れる</h4><p>一度調べて打ったコマンドはもう一度打ちたくない</p><ul><li>cd履歴をpecoで絞り込む</li><li>コマンド履歴をpecoで絞り込む</li><li>過去の履歴からコマンドの補完が行われる(zsh-autosuggestions)</li></ul><h4 id=プロンプトに必要な情報を載せる>プロンプトに必要な情報を載せる</h4><p>本番環境でうっかりコマンド実行、実行しちゃいけないディレクトリでうっかり(ryがないようにする</p><ul><li>git関係(今commitできるものがあるか・pullできるものがあるか)</li><li>hostname</li><li>pwd</li></ul><h3 id=地味に便利なsyntaxハイライトzsh-syntax-highlighting>地味に便利なsyntaxハイライト(zsh-syntax-highlighting)</h3><p>プログラムがあるかの確認などにwhichとかしなくて良い。打っている途中でコマンドが間違っているか視覚的に気づける</p><h3 id=vimrc>vimrc</h3><p>続いてvimrcです。vimrcも削りに削って200行くらいですが、意識していることは</p><ul><li>vimscriptのみで動くプラグインを入れる</li></ul><p>なんかpythonとかluaとか必要とするプラグインは使わないです。プラグインマネージャはvim-plugを使ってます。</p><p>おすすめプラグインは<a href=https://vimawesome.com/>vimawesome</a>で探すと良いと思います。利用者数順やstar数順でプラグインが紹介されていて、ジャンル別のランキングも見れます。</p><ul><li><a href=https://github.com/kien/ctrlp.vim>ctrlp.vim</a>: C-pで最近開いたファイル開くやつ</li><li><a href=https://github.com/scrooloose/nerdtree>nerd tree</a>: finder</li><li><a href=https://github.com/airblade/vim-gitgutter>vim-gitgutter</a>: gitで編集しているファイルを編集すると+-っていう差分を示すマークが出るようになるやつ</li><li><a href=https://github.com/ntpeters/vim-better-whitespace>vim-better-whitespace</a>: ワンコマンドでいらない空白を排除するやつ</li></ul><h3 id=gitconfig--gitignore>gitconfig & gitignore</h3><p>gitconfigは地味に便利なので、dotfilesで管理することをおすすめします。
aliasの設定が便利です。</p><pre tabindex=0><code>co = checkout
s = status --short --branch
b = branch -a
cm = commit -v
cma = commit -a -v
d = diff -C --stat -p
dc = diff --cached
br = branch
s = status --short --branch
rv = remote --verbose
l = log --graph --date=short --decorate=short --pretty=format:&#39;%C(red)%h　%C(reset)-%C(yellow)%d %Creset%s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;
ll = log --graph --all --abbrev-commit --date=relative --pretty=format:&#39;%C(red)%h　%C(reset)-%C(yellow)%d %Creset%s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;
</code></pre><p>gitignoreはグローバルにignoreしたいファイルを書きます。キャッシュ系のファイルと、.key、.pemなども書いておくとうっかりがないです。</p><h2 id=makefileの作成>Makefileの作成</h2><p>後ほどインストールスクリプトを書くんですが、その中ではほぼmakeのinstallタスクを実行するだけなので、先にMakefileを書きます。ちょっと抜粋すると</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>install: vim-init zsh-init
</span></span><span style=display:flex><span>	@<span style=color:#66d9ef>$(</span>foreach val, <span style=color:#66d9ef>$(</span>DOTFILES_FILES<span style=color:#66d9ef>)</span>, ln -sfnv <span style=color:#66d9ef>$(</span>abspath <span style=color:#66d9ef>$(</span>val<span style=color:#66d9ef>))</span> <span style=color:#66d9ef>$(</span>HOME<span style=color:#66d9ef>)</span>/<span style=color:#66d9ef>$(</span>val<span style=color:#66d9ef>)</span>;<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>	vim +PlugInstall +qall
</span></span><span style=display:flex><span>	zsh
</span></span><span style=display:flex><span>vim-init: ctags-init
</span></span><span style=display:flex><span>	curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</span></span></code></pre></div><ul><li>必要なバイナリ(peco、vimのプラグインマネージャなど)を持ってくる</li><li>dotfilesをシンボリックリンクを用いてホームディレクトリに設置する</li><li>vimのプラグインインストール</li><li>zshの再起動で全設定完了</li></ul><p>といったことをしてます。</p><h3 id=なぜmakefileか>なぜMakefileか</h3><p>プログラムのビルドの自動化で使うMakefileをdotfilesのインストールにも用いるのには以下の3つの理由があるからです。</p><ul><li>どこでも入っているから。Makefileとシェルスクリプトを使うのはそのため</li><li>自動でインストールされるものと必要な環境にインストールするものを分けたい<ul><li>pecoは自動で入れてほしいけど、ghqは必要な環境だけにインストールしたいみたいなことができる</li></ul></li><li>make タスク名で実行できるので、長いインストールスクリプトを忘れても良い</li></ul><h3 id=デプロイinstallとイニシャライズinitは分ける>デプロイ(install)とイニシャライズ(init)は分ける</h3><p>installはシンボリックリンクを貼ったりパスに置いたりしてプログラムを使えるようにすること、initはダウンロードなど必要なプログラムを外部から取得することを指します。</p><p>これは、<a href=https://qiita.com/b4b4r07/items/b70178e021bef12cd4a2>最強の dotfiles 駆動開発と GitHub で管理する運用方法</a>の引用なのですが</p><blockquote><p>ドットファイルを一括でターゲットとすることで、新規ドットファイルが追加されてもこの Makefile を修正する必要がないので便利です（ファイルの追加に追従してリンクファイルの修正することを忘れたり、ファイルリストから漏れたりすることで、リンクされないようなバグやそれに関するコンフリクトはよくあります）</p></blockquote><p>シンボリックリンクを貼るタスクと、諸々ツールインストールするタスクが一緒になっていた場合、新しくdotfilesを足してシンボリックリンク貼りたいだけにもかかわらず、ツールが再度インストールされてしまったりといったことがあり得る。そのためinstallとinitのMakeタスクは分けましょう。</p><h3 id=環境ごとに違うバイナリをインストールする場合>環境ごとに違うバイナリをインストールする場合</h3><p>macとlinuxなど環境ごとに異なるバイナリをインストールするためには、Makefileの中で判定させます。
例えばpecoのインストールタスクは以下のようになってます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>UNAME :<span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>shell uname<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>peco-init:
</span></span><span style=display:flex><span>ifeq <span style=color:#f92672>(</span><span style=color:#66d9ef>$(</span>UNAME<span style=color:#66d9ef>)</span>,Darwin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>	curl -L -O https://github.com/peco/peco/releases/download/v0.5.1/peco_darwin_amd64.zip
</span></span><span style=display:flex><span>	unzip peco_darwin_amd64.zip <span style=color:#f92672>&amp;&amp;</span> sudo mv peco_darwin_amd64/peco /usr/local/bin <span style=color:#f92672>&amp;&amp;</span> rm -rf peco_darwin_amd64 peco_darwin_amd64.zip
</span></span><span style=display:flex><span>endif
</span></span><span style=display:flex><span>ifeq <span style=color:#f92672>(</span><span style=color:#66d9ef>$(</span>UNAME<span style=color:#66d9ef>)</span>,Linux<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>	curl -L -O https://github.com/peco/peco/releases/download/v0.5.1/peco_linux_amd64.tar.gz
</span></span><span style=display:flex><span>	tar -zxvf peco_linux_amd64.tar.gz <span style=color:#f92672>&amp;&amp;</span> sudo mv peco_linux_amd64/peco /usr/local/bin <span style=color:#f92672>&amp;&amp;</span> rm -rf peco_linux_amd64 peco_linux_amd64.tar.gz
</span></span><span style=display:flex><span>endif
</span></span></code></pre></div><p>unameコマンドを最初に打っておき、その結果でifeqを用いてどちらかのバイナリを取得します。</p><h2 id=インストールスクリプトの作成>インストールスクリプトの作成</h2><p>最後にインストールスクリプト作成します。インストールスクリプトでやることはシンプルで</p><ul><li>git clone</li><li>make install</li></ul><p>だけです。他はかっこよくアスキーアート出したりしてもよいかと思います。自分のインストールスクリプトは短いのでほぼ全文以下に記載します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># check git</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> ! type git &gt; /dev/null 2&gt;&amp;1; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;this dotfiles is required gitd&#34;</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;please retry when you install git&#34;</span>
</span></span><span style=display:flex><span>  exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># echo logo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;</span>$DOTFILES_LOGO<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># git clone</span>
</span></span><span style=display:flex><span>git clone <span style=color:#e6db74>${</span>REPO_URL<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># make</span>
</span></span><span style=display:flex><span>cd dotfiles <span style=color:#f92672>&amp;&amp;</span> make
</span></span></code></pre></div><p>これをinstaller.shとしてgitにあげておき</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>bash -c <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>curl -L https://raw.githubusercontent.com/dais0n/dotfiles/master/rc/installer.sh<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>で実行すればinstaller.shが起動します。</p><h2 id=よく忘れるコマンドをどの環境でも打つ方法>よく忘れるコマンドをどの環境でも打つ方法</h2><p>おまけで、よく忘れるコマンドをスニペットとして登録しておき、スニペットをどの環境でも使う簡単な方法を紹介します。</p><ol><li>.zsh/snippetを作る</li><li>snippetの内容を呼び出して表示するzshの関数を作る</li></ol><p>上記の2ステップで実現できます。</p><h3 id=zshsnippetを作る>.zsh/snippetを作る</h3><p>.zsh/snippetはただのコマンド羅列ファイルですｗ以下によく忘れるコマンドを記載してdotfilesとして管理します。コマンドの後ろに#をつけてコメントを書くと良いです。例えば以下用な感じです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># git</span>
</span></span><span style=display:flex><span>git commit --amend
</span></span><span style=display:flex><span>git branch -D <span style=color:#75715e># delete local branch</span>
</span></span><span style=display:flex><span>git push --delete origin branch_name <span style=color:#75715e># delete remote branch</span>
</span></span><span style=display:flex><span>git show-branch | grep <span style=color:#e6db74>&#39;*&#39;</span> | grep -v <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>git rev-parse --abbrev-ref HEAD<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> | head -1 | awk -F<span style=color:#e6db74>&#39;[]~^[]&#39;</span> <span style=color:#e6db74>&#39;{print $2}&#39;</span> <span style=color:#75715e># check parent branch</span>
</span></span><span style=display:flex><span>git log --oneline | peco | cut -d<span style=color:#e6db74>&#34; &#34;</span> -f1 | xargs git show <span style=color:#75715e># git show</span>
</span></span><span style=display:flex><span>git submodule update -i <span style=color:#75715e># git submodule</span>
</span></span><span style=display:flex><span><span style=color:#75715e># curl</span>
</span></span><span style=display:flex><span>curl -H <span style=color:#e6db74>&#34;Content-Type: application/json&#34;</span> -X POST -d <span style=color:#e6db74>&#39;{&#34;username&#34;:&#34;xyz&#34;,&#34;password&#34;:&#34;xyz&#34;}&#39;</span> http://localhost:3000/v1/login
</span></span><span style=display:flex><span><span style=color:#75715e># kubernetes</span>
</span></span><span style=display:flex><span>kubectl config set-context <span style=color:#66d9ef>$(</span>kubectl config current-context<span style=color:#66d9ef>)</span> --namespace<span style=color:#f92672>=</span>&lt;YOUR_NAMESPACE&gt; <span style=color:#75715e># change namespace</span>
</span></span><span style=display:flex><span><span style=color:#75715e># investigation</span>
</span></span><span style=display:flex><span>netstat -ltapn | grep ESTABLISHED | more
</span></span><span style=display:flex><span>netstat -ltan | grep <span style=color:#e6db74>&#34;:80 &#34;</span> | awk <span style=color:#e6db74>&#39;{print $5}&#39;</span> | awk -F : <span style=color:#e6db74>&#39;{print $4}&#39;</span> | sort | uniq -c | sort -nr | head
</span></span><span style=display:flex><span>lsof -i:80
</span></span><span style=display:flex><span>nc localhost <span style=color:#ae81ff>8080</span> <span style=color:#75715e># netcat</span>
</span></span></code></pre></div><h3 id=snippetの内容を呼び出して表示するzshの関数を作る>snippetの内容を呼び出して表示するzshの関数を作る</h3><p>作成したsnippetファイルをpecoを使ってインクリメンタルサーチさせます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#66d9ef>function</span> peco-snippets<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    BUFFER<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>grep -v <span style=color:#e6db74>&#34;^#&#34;</span> ~/.zsh/snippets | peco --query <span style=color:#e6db74>&#34;</span>$LBUFFER<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>    zle reset-prompt
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>zle -N peco-snippets
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;^S&#39;</span> peco-snippets
</span></span></code></pre></div><p>コメント行のみを覗いてpecoで絞り込みをかけてくれます。そうすると以下のようにどの環境でも忘れやすいコマンドを検索できるようになります。</p><figure><img src=../../../images/dotfiles_in_anywhere_2.png></figure><p>シンプルですが自分はこのsnippet管理方法が好きです。</p><h2 id=参考>参考</h2><p><a href=https://qiita.com/b4b4r07/items/b70178e021bef12cd4a2>最強の dotfiles 駆動開発と GitHub で管理する運用方法</a></p></article></section><span class=date><time datetime=2019-01-27>Sun, 27 Jan 2019</time></span><footer id=footer>&copy; 2023
<a href=https://blog.dais0n.net/ style=text-decoration:none>blog.dais0n.net</a>
/ <a href=https://www.youtube.com/channel/UC0jYN0VlTIl0Tgg8Y41QuIw target=_blank rel="noopener noreferrer" style=text-decoration:none>YouTube</a>
/ <a href=https://github.com/dais0n target=_blank rel="noopener noreferrer" style=text-decoration:none>Github</a></footer></div></body></html>